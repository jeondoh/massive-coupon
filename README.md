# 선착순 쿠폰 이벤트 프로젝트
대규모 트래픽 환경에서 선착순 쿠폰 발급을 안정적으로 처리하기 위한 시스템 설계 및 성능 개선 프로젝트
> 선착순 쿠폰 이벤트와 같이 짧은 시간에 트래픽이 집중되는 상황을 가정하여, 정합성(1인 1매 / 재고 초과 발급 방지)를 보장하면서 부하테스트, 모니터링 지표 기반으로 병목을 제거하는 것을 목표로 합니다.

## 📖 Wiki  
- 프로젝트 진행 중 겪었던 문제 해결 과정과 성능 개선 과정에 대한 더 자세한 내용은 아래 Wiki 페이지에서 확인하실 수 있습니다.  
- [Wiki로 이동하기](https://github.com/jeondoh/massive-coupon/wiki)

## 기술 스택
![stack](https://github.com/user-attachments/assets/d963d0de-9564-4504-bfca-3401f72b8327)

## 서버 아키텍처

### 1. 라우팅 서버
- 모든 클라이언트 요청의 진입 지점이며, 현재 트래픽 상황 및 이벤트 상태에 따라 요청을 대기열 서버 또는 쿠폰 서버로 동적 라우팅합니다.
- 대량의 동시 요청을 효율적으로 처리하기 위해 Spring WebFlux 기반의 비동기-논블로킹 구조로 구현하였습니다.
> 목적: 지정한 트래픽 수치(RPM)에 따라 빠르게 대기열 필요 여부를 판단하여 목적에 맞게 라우팅

### 2. 대기열 서버
- 선착순 처리를 위한 대기열(waiting, running queue)를 관리합니다.
- 사용자 진입 순서를 관리하며, 스케줄러를 통해 대기열간 사용자 이동처리, 이탈 또는 타임아웃된 사용자를 정리합니다.
- 쿠폰 발급 서버로 진입 가능한 동시 처리 인원을 제한하여 시스템 부하를 제어합니다.
> 목적: 공정한 순서 보장과 발급 단계로 유입되는 트래픽 제어

### 3. 쿠폰 서버
- 쿠폰 이벤트 참여 요청을 처리하는 비즈니스 API 서버입니다.
- 쿠폰 재고 상태 및 중복 발급 여부를 검증하는 역할을 담당합니다.
- 발급 가능 요청에 대해서만 쿠폰 발급 서버로 처리를 위임합니다.
> 목적: 쿠폰 발급 전 검증 책임을 담당하며, 유저에게 빠른 응답 제공

### 4. 쿠폰 발급 서버
- 실제 쿠폰 발급 처리 및 DB 영속화를 담당합니다.
- 검증이 완료된 요청만 전달받아 쿠폰 발급 이력을 저장합니다.
- 발급 로직을 분리함으로써, 트래픽 변동과 무관하게 안정적인 발급 처리가 가능하도록 설계하였습니다.
> 목적: 발급 책임을 독립시켜 장애 범위 최소화 및 트랜잭션 안정성 확보

# 성능 개선 과정
## 1️⃣ 단일 서버, DB 비관락 기반 구조  

DB 비관락을 중심으로 정합성을 확보하였고,  
부하테스트를 통해 병목을 지표로 확인한 뒤 락 유지 시간과 트랜잭션 범위를 축소하는 개선을 진행하였습니다.

### 문제 상황
- 쿠폰 발급 과정이 모두 하나의 동기 트랜잭션 내에서 처리
  - 비관락 기반 중복 체크, 상세 조회, 쿠폰 발급과 재고 차감까지 모든 과정들이 한 트랜잭션 내에서 동기적으로 처리
  - 순차적으로 요청이 처리되면서 요청수에 비례해 응답시간이 기하급수적으로 증가
- 비관락 경합으로 인한 처리 지연
  - 동일 쿠폰 Row 에 대한 락 경합 발생
  - 락 대기로 인한 트랜잭션 지연, 커넥션 점유 시간이 증가되면서 timeout 위험 증가

### 개선 내용
- 데이터베이스 기반 동시성 제어 제거
  - 쿠폰 발급에 필요한 정보들을 메타데이터로 만들어 Redis에 캐싱하여 데이터베이스 검색 비용을 제거하였습니다.
  - 중복 발급, 재고 차감의 동시성이 필요한 부분을 Redis Lua Script 원자 연산으로 빠르게 처리하도록 하였습니다.
- 트랜잭션 분리, 이벤트 기반 비동기 처리 도입
  - 쿠폰 발급 로직은 spring event를 통해 데이터베이스에 영속화 하도록 하였습니다.
  - 이벤트 처리에 사용되는 스레드 생성 비용을 줄이고, I/O Bound 작업에 특화되어있는 Virtual Thread를 활용하였습니다.

### 개선 전
![k6-response-time](https://github.com/user-attachments/assets/5cd556b5-b9c0-43bb-b7b0-1a08ae5ffc09)
![hikariCP](https://github.com/user-attachments/assets/61e50599-d6ab-45bc-aece-04b382974b99)
![mysql-dashboard](https://github.com/user-attachments/assets/7654ff17-38b7-4f83-86f9-23e24bc50a5c)

### 개선 후
![k6-dashboard](https://github.com/user-attachments/assets/b7051123-04bf-431d-b021-a7f6a8fa2430)
![hikari-cp](https://github.com/user-attachments/assets/4e1da825-9026-493a-b9d8-4420c8992acd)

### 개선 결과
- VUser: 1000
- P95: **2.02s -> 0.049s** `40배 향상`
- Row Lock Blocking: **48.7% -> 0%** `락 제거`
- Thread Peak: **100 -> 20** `80% 감소`
- Connection Pool Peak: **30(active) + 7(pending)** -> 18 `50% 감소`

## 2️⃣ 서버 분리, 다중 서버 + 대기열 기반 구조
선착순 이벤트 도메인은 짧은 시간 동안 대량의 요청이 집중되는 특성을 가집니다.  
모든 요청을 받아 동시에 처리하게 될 경우 시스템 과부하, 장애 및 데이터베이스 병목이 발생할 가능성이 높다고 판단하였습니다.  
이에 따라, 서비스 공정성과 안정성 그리고 예측 가능한 부하를 제어하기 위해 대기열을 도입하였습니다.  
대기열 도입과 함께 책임을 명확히 분리할 필요성이 커졌고, 4개의 독립적인 서버로 분리하였습니다.  
서버별 기술적 책임뿐 아니라 확장성과 리소스 사용의 안정성까지 확보할 수 있었습니다.

### 대기열 시퀀스 다이어그램
![sequencediagram](https://github.com/user-attachments/assets/88b9408c-b08c-4f53-9284-de37bf5b1877)

### 대기열 판단 과정
1. 클라이언트가 이벤트 페이지 진입 요청을 보내면, 라우팅 서버는 Redis에 저장된 트래픽 임계치 설정(trafficRpm)과 현재 요청량을 비교하여 대기열 적용 여부를 판단합니다.
2. 요청량이 임계치 이하인 경우, 라우팅 서버는 요청을 쿠폰 서버로 포워딩하고, 반환된 이벤트 페이지 정보를 기반으로 쿠폰 이벤트 페이지 진입을 허용합니다.
3. 요청량이 임계치를 초과한 경우, 라우팅 서버는 클라이언트에게 대기열 페이지로 리다이렉트 응답을 반환합니다.

### 대기열 진입 과정
1. 클라이언트가 대기열 페이지에서 대기열 진입 요청을 보냅니다.
2. 라우팅 서버는 대기열 서버로 포워딩, 대기열 서버는 waiting-queue로 유저 삽입과 함께 대기 순번을 반환합니다.
3. 클라이언트가 지정된 시간(n초) 간격으로 대기열 순번 갱신 요청을 보냅니다.
4. 라우팅 서버는 대기열 서버로 포워딩, 대기열 서버는 사용자의 현재 상태를 확인합니다.
5. 아직 waiting queue에 존재할 경우, 현재 대기 순번을 반환합니다.
6. 스케줄러를 통해 running queue로 이동이 되었다면, 쿠폰 이벤트 페이지로 진입 가능 상태를 반환합니다.

### 쿠폰 발급 과정
1. 클라이언트가 이벤트 페이지에서 쿠폰 발급 요청을 보냅니다.
2. 라우팅 서버는 쿠폰 서버로 포워딩, 쿠폰 서버는 재고 및 중복 발급 유효성 검증을 처리합니다.
3. 검증이 성공할 경우 쿠폰 지급 요청 이벤트를 메시지 큐로 발행하고, 클라이언트에게 완료 응답을 반환합니다.
4. 쿠폰 발급 서버는 메세지 큐로부터 이벤트를 소비하여 쿠폰 발급 이력을 데이터베이스에 저장합니다.

### 부하테스트
4500 VUser 동시 요청 환경을 구성했고,  
유저 수 대비 더 많은 요청 부하를 발생시키기 위해 대기 순번 polling 주기를 기존 3초에서 300ms로 요청 수 10배를 증가시켰습니다.  
실제 사용자 수 보다 더 많은 요청 패턴을 만들어 한계 상황을 검증하고자 하였습니다.

### 테스트 결과
![k6](https://github.com/user-attachments/assets/e5824aa0-76bf-48b2-a365-285fc7770c40)
![responseTime](https://github.com/user-attachments/assets/538d62f5-8aae-4c38-8a50-07e046bfc371)
![ops](https://github.com/user-attachments/assets/3e5ebe6a-3bdd-4ad4-85d2-f4107119430f)

### 개선 결과
- 평균 응답 시간: **2.02s -> 43ms** `약 98% 감소`
- 최대 응답 시간: **4.69s -> 1.86s** `약 60% 감소`
- Row Lock Blocking: **48.7% -> 0%** `락 제거`
